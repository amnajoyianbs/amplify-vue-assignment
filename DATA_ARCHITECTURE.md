# Data Architecture - Asset Management System

## Overview

This application uses a **hybrid data architecture** with clear separation of concerns:

1. **RDS MySQL** - Primary asset data (via API Gateway + Lambda)
2. **DynamoDB** - Metadata only (via GraphQL/AppSync)
3. **S3** - Image storage
4. **No localStorage** - All data persists in AWS services

## Data Flow

### Asset CRUD Operations (RDS via API Gateway)

```
Frontend (Vue)
  ↓ Cognito JWT Token
API Gateway
  ↓ Validates JWT
  ↓ Authorizes request
Lambda (asset-api)
  ↓ Extracts user ID from token
  ↓ Queries with user filter
MySQL RDS
```

**Stored in RDS:**
- `id` (UUID)
- `name` (string)
- `description` (text)
- `category` (string)
- `imageUrl` (S3 URL)
- `userId` (Cognito sub)
- `createdAt` (timestamp)
- `updatedAt` (timestamp)

**API Endpoints:**
- `GET /assets` - List all user's assets
- `GET /assets/{id}` - Get single asset
- `POST /assets` - Create new asset
- `PUT /assets/{id}` - Update asset
- `DELETE /assets/{id}` - Delete asset

### Metadata Operations (DynamoDB via GraphQL)

```
Frontend (Vue)
  ↓ Cognito JWT Token
AppSync GraphQL API
  ↓ Validates JWT
  ↓ Applies @auth rules
DynamoDB
```

**AssetInfo Model (DynamoDB):**
- `id` (auto-generated)
- `assetId` (reference to RDS asset)
- `tags` (array of strings)
- `status` (enum: active/inactive/archived)
- `notes` (string)
- `userId` (owner field)

**AssetLog Model (DynamoDB):**
- `id` (auto-generated)
- `assetId` (reference to RDS asset)
- `action` (enum: created/updated/deleted/viewed)
- `timestamp` (datetime)
- `userId` (owner field)
- `details` (string)

**GraphQL Operations:**
```graphql
# Create metadata
mutation CreateAssetInfo {
  createAssetInfo(input: {
    assetId: "uuid"
    tags: ["tag1", "tag2"]
    status: active
    notes: "Some notes"
    userId: "cognito-sub"
  }) {
    id
    assetId
    tags
    status
  }
}

# Query metadata
query GetAssetInfo {
  listAssetInfos(filter: { assetId: { eq: "uuid" } }) {
    items {
      id
      tags
      status
      notes
    }
  }
}

# Create log entry
mutation CreateAssetLog {
  createAssetLog(input: {
    assetId: "uuid"
    action: updated
    userId: "cognito-sub"
    details: "Changed category"
    timestamp: "2024-02-09T..."
  }) {
    id
  }
}
```

### Image Storage (S3)

```
Frontend
  ↓ Upload file
S3 (assetImages bucket)
  ↓ Returns URL
Frontend
  ↓ Saves URL to RDS via API
```

**S3 Path Structure:**
```
assets/{assetId}/{filename}
```

**Access Control:**
- Authenticated users can: read, write, delete
- Path: `assets/*`

## State Management

### Frontend Store (Pinia)

**In-Memory Only:**
```typescript
{
  assets: Asset[],        // Fetched from API, not persisted
  currentAsset: Asset | null,
  loading: boolean,
  error: string | null
}
```

**No localStorage:**
- Assets are NOT stored in browser
- All data fetched fresh from API on page load
- State cleared on logout/refresh

### Service Layer

**assetService.ts:**
- All methods call API Gateway endpoints
- No fallback to localStorage
- Throws errors if API fails
- Requires authentication token

```typescript
// ✅ Correct - API only
await assetService.listAssets()

// ❌ Removed - No localStorage fallback
// localStorage.getItem('assets')
```

## Data Consistency

### Primary Keys
- **RDS**: UUID generated by database
- **DynamoDB**: Auto-generated by AppSync
- **Relationship**: `AssetInfo.assetId` → `Asset.id` (RDS)

### User Isolation
- **RDS**: Lambda filters by `userId` from JWT
- **DynamoDB**: AppSync @auth rules enforce owner access
- **S3**: IAM policies restrict to authenticated users

### Timestamps
- **RDS**: `createdAt`, `updatedAt` managed by Sequelize
- **DynamoDB**: `timestamp` set by application

## Security

### Authentication
- All requests require Cognito JWT token
- API Gateway validates token before Lambda invocation
- AppSync validates token before DynamoDB access

### Authorization
- **Row-level security**: Users only see their own assets
- **Lambda**: Filters queries by `userId`
- **GraphQL**: `@auth(rules: [{ allow: owner }])`

### Data Access
```
User A (userId: abc123)
  ↓ Can access
  - Assets where userId = abc123 (RDS)
  - AssetInfo where userId = abc123 (DynamoDB)
  - AssetLog where userId = abc123 (DynamoDB)
  
  ↓ Cannot access
  - Any data from User B
```

## Performance Optimization

### Caching Strategy
- **Frontend**: In-memory cache (Pinia store)
- **API Gateway**: Can enable caching for GET requests
- **RDS**: Connection pooling in Lambda
- **DynamoDB**: Single-table design for fast queries

### Query Optimization
- **RDS**: Indexes on `userId`, `category`
- **DynamoDB**: GSI on `assetId` for metadata lookups
- **S3**: CloudFront CDN for images (optional)

## Error Handling

### API Failures
```typescript
try {
  await assetService.listAssets()
} catch (error) {
  // Show error to user
  // No fallback to localStorage
  throw error
}
```

### Network Issues
- Display error message
- Retry button
- No offline mode (all data in cloud)

## Migration Path

### From localStorage to API
1. ✅ Remove all localStorage.getItem/setItem calls
2. ✅ Remove fallback methods in assetService
3. ✅ All CRUD operations go through API
4. ✅ Store only keeps in-memory state

### Future Enhancements
- Add Redis cache layer
- Implement GraphQL subscriptions for real-time updates
- Add offline support with sync queue
- Implement optimistic UI updates

## Testing

### API Integration Tests
```bash
# Test asset creation
curl -X POST https://api-url/assets \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"name":"Test","category":"electronics"}'

# Test asset retrieval
curl -X GET https://api-url/assets \
  -H "Authorization: Bearer $TOKEN"
```

### GraphQL Tests
```graphql
# Test metadata creation
mutation {
  createAssetInfo(input: {
    assetId: "test-uuid"
    tags: ["test"]
    userId: "test-user"
  }) {
    id
  }
}
```

## Monitoring

### CloudWatch Metrics
- API Gateway: Request count, latency, errors
- Lambda: Invocations, duration, errors
- RDS: Connections, CPU, storage
- DynamoDB: Read/write capacity, throttles

### Logging
- Lambda logs: `/aws/lambda/asset-api`
- API Gateway logs: `/aws/apigateway/AssetManagementApi`
- Application errors logged to CloudWatch

## Cost Optimization

### RDS
- Use t3.micro for development
- Enable auto-pause for Aurora Serverless
- Set appropriate backup retention

### DynamoDB
- On-demand pricing for variable workload
- Or provisioned capacity with auto-scaling

### Lambda
- Optimize memory allocation
- Use Lambda layers for dependencies
- Set appropriate timeout values

### S3
- Use S3 Intelligent-Tiering
- Enable lifecycle policies
- Compress images before upload
